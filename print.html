<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bevy_northstar Documentation</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="grid_settings.html"><strong aria-hidden="true">3.</strong> Grid Settings</a></li><li class="chapter-item expanded "><a href="nav_data.html"><strong aria-hidden="true">4.</strong> Navigation Data</a></li><li class="chapter-item expanded "><a href="grid_updates.html"><strong aria-hidden="true">5.</strong> Grid Updates</a></li><li class="chapter-item expanded affix "><li class="part-title">Pathfinding</li><li class="chapter-item expanded "><a href="pathfinding/01_plugin.html"><strong aria-hidden="true">6.</strong> With NorthstarPlugin</a></li><li class="chapter-item expanded "><a href="pathfinding/02_modes.html"><strong aria-hidden="true">7.</strong> Modes / Algorithms</a></li><li class="chapter-item expanded "><a href="pathfinding/03_path.html"><strong aria-hidden="true">8.</strong> Path Component/Struct</a></li><li class="chapter-item expanded "><a href="pathfinding/04_manual_pathfinding.html"><strong aria-hidden="true">9.</strong> Manual Pathfinding</a></li><li class="chapter-item expanded affix "><li class="part-title">Neighborhood</li><li class="chapter-item expanded "><a href="neighborhood/01_neighborhoods.html"><strong aria-hidden="true">10.</strong> Neighborhoods</a></li><li class="chapter-item expanded "><a href="neighborhood/02_filters.html"><strong aria-hidden="true">11.</strong> Filters</a></li><li class="chapter-item expanded affix "><li class="part-title">Navigation Masks</li><li class="chapter-item expanded "><a href="navigation_masks.html"><strong aria-hidden="true">12.</strong> Navigation Masks</a></li><li class="chapter-item expanded affix "><li class="part-title">Debugging</li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">13.</strong> Debugging</a></li><li class="chapter-item expanded affix "><li class="part-title">Migration Guides</li><li class="chapter-item expanded "><a href="migrations/001_v0.3.0.html"><strong aria-hidden="true">14.</strong> From v0.2.X to v0.3.X</a></li><li class="chapter-item expanded "><a href="migrations/002_v0.4.0.html"><strong aria-hidden="true">15.</strong> From v0.3.X to v0.4.X</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">bevy_northstar Documentation</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/jtothethree/bevy_northstar"><code>bevy_northstar</code></a> is a <a href="https://alexene.dev/2019/06/02/Hierarchical-pathfinding.html"><code>Hierarchical Pathfinding</code></a> plugin for <a href="https://bevy.org/">Bevy</a>.</p>
<p>The crate provides:</p>
<ul>
<li>
<p>Pathfinding Grids: A grid defines the navigable area and stores precalculated neighbors, chunks, entrances, and internal paths used for pathfinding.</p>
</li>
<li>
<p>Pathfinding Systems: Bevy systems to handle pathfinding and collision avoidance for you.</p>
</li>
<li>
<p>Pathfinding Algorithms: You can call the pathfinding functions directly if you desire to handle the pathfinding logic in your own systems or just want to do a one off call.</p>
</li>
<li>
<p>Debugging Tools: Easily visualize the grid and calculated paths to troubleshoot any tilemap and pathfinding issues.</p>
</li>
</ul>
<p>The crate is currently designed for use with 2d and 3d grid based tilemaps. It is not dependent on any specific tilemap Bevy crate, though it's been designed for ease of use with <a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a> and any related crates such as <a href="https://github.com/adrien-bon/bevy_ecs_tiled"><code>bevy_ecs_tiled</code></a> and <a href="https://github.com/Trouv/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code></a>.</p>
<h1 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h1>
<img src="../bevy_northstar/images/hpaoverview.png" width="80%"/>
<p>Hierarchical pathfinding works by dividing the map into chunks and identifying viable connections between each chunk at their edges. This creates a network of high-level graph nodes across the map.</p>
<p>Instead of searching the entire map at once, pathfinding can use these high-level nodes to run a simplified A* search over a much smaller set of positions, which significantly speeds up the process.</p>
<p>Additionally, for each high-level node, paths through the local chunk to all other chunk nodes can be precomputed and stored. After the high-level search is complete, these precomputed paths are reused, so the algorithm doesn't need to search through every chunk individually.</p>
<p>Once the high-level path is found, it is refined using a line tracing algorithm to make the path more optimal.</p>
<p>In the picture above, the high-level path is shown in blue, and the red line shows the final refined path built from it.</p>
<h1 id="who-this-crate-is-for"><a class="header" href="#who-this-crate-is-for">Who This Crate Is For</a></h1>
<p>The current target for this crate is for games with large tile based maps and designed to support large sim games like Dwarf Fortress or Rimworld, RPGs with grid like movement like Fallout 1/2, and Roguelikes. </p>
<p>It does not support Flowfield pathfinding which is better suited in RTS games where many agents are often pathfinding to the single goal. HPA* is better suited for many agents with their own unique goals.</p>
<p>Nav meshes are not supported yet but are planned; they’re better suited for games with freeform movement, think Zelda-style movement, rather than grid-constrained paths. You can certainly abstract the grid-based paths to freeform movement though.</p>
<p>Other crates that might fit those projects better:</p>
<h4 id="flowfield"><a class="header" href="#flowfield">Flowfield</a></h4>
<ul>
<li><a href="https://crates.io/crates/bevy_pathfinding">bevy_pathfinding</a></li>
<li><a href="https://crates.io/crates/bevy_flowfield_tiles_plugin">bevy_flowfield_tiles_plugin</a></li>
</ul>
<h4 id="navmesh"><a class="header" href="#navmesh">NavMesh</a></h4>
<ul>
<li><a href="https://crates.io/crates/vleue_navigator">vleue_navigator</a></li>
<li><a href="https://crates.io/crates/bevy_landmass">bevy_landmass</a></li>
</ul>
<h4 id="diy-a"><a class="header" href="#diy-a">DIY A*</a></h4>
<ul>
<li><a href="https://crates.io/crates/pathfinding">pathfinding</a>: The general pathfinding crate is a good place to start if you just want to implement simple A*.</li>
</ul>
<h1 id="3d-why-and-when"><a class="header" href="#3d-why-and-when">3D: Why and When</a></h1>
<p>Even if your game is technically 2D, many 2D tilemap games feature 3D movement often referred to as 2.5D. Isometric games are a great example, but even top-down games like Zelda often include a concept of depth. There are also fully 3D games that use grid-based movement in three dimensions, such as X-COM.</p>
<p>If your 2D game allows regular movement between floors or terrain levels, you’ll likely want to use a 3D grid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<h2 id="cargo-setup"><a class="header" href="#cargo-setup">Cargo Setup</a></h2>
<p>Add required dependencies to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
bevy = &quot;0.16&quot;
bevy_northstar = &quot;0.3&quot;
</code></pre>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<h4 id="stats"><a class="header" href="#stats"><code>Stats</code></a></h4>
<p>Enable statistics reporting, includes pathfinding, collision avoidance, and grid build time stats. Useful for diagnosing frame spikes. See <a href="./debugging.html">Debugging</a>.</p>
<h4 id="parallel-enabled-by-default"><a class="header" href="#parallel-enabled-by-default"><code>Parallel</code> <em>(Enabled by default)</em></a></h4>
<p>Uses <code>rayon</code> to build the navigation grid in parallel. This greatly speeds up grid rebuilds, but may cause issues in WASM builds.
To disable parallelism (e.g. for WASM support), disable default features:</p>
<pre><code class="language-toml">bevy_northstar = { version = &quot;0.3&quot;, default-features = false }
</code></pre>
<blockquote>
<p><strong>⚠️ Warning</strong><br />
If you disable <code>parallel</code>, rebuilding the grid during gameplay (e.g. mining, explosions, etc.) can be quite expensive. You will want to confine your updates in a single frame to the least amount of affected chunks.</p>
</blockquote>
<h3 id="debug-optimization"><a class="header" href="#debug-optimization">Debug Optimization</a></h3>
<p>Pathfinding and grid algorithms involve a lot of branching, which can make debug builds significantly slower. You can set the optimization settings for this crate so you can still debug your game without the performance hit.</p>
<p>Follow <a href="https://bevy.org/learn/quick-start/getting-started/setup/#cargo-workspaces">Bevy Quickstart Cargo Workspaces</a> to add <code>opt-level = 3</code> to your <code>Cargo.toml</code> dependencies.</p>
<p>Or alternatively add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.dev.package.&quot;bevy_northstar&quot;]
opt-level = 3
</code></pre>
<h2 id="crate-usage"><a class="header" href="#crate-usage">Crate Usage</a></h2>
<p>The basic requirements to use the crate are to spawn an entity with a <code>Grid</code> component, adjust the navigation data, and then call <code>Grid::build()</code> so the chunk entrances and internal paths can be calculated. </p>
<p>To use the built-in pathfinding systems for the crate, add the <code>NorthstarPlugin</code> specifying the <code>Neighborhood</code> to use.</p>
<p><code>CardinalNeighborhood</code> (North, East, South, West) is a good neighborhood to start with. See <a href="./neighborhood/01_neighborhoods.html">Neighborhoods</a> for the full list and details.</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_northstar::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // Add the Northstar Plugin with a selected neighborhood to use the built-in pathfinding systems
        .add_plugins(NorthstarPlugin::&lt;CardinalNeighborhood&gt;::default())
        .add_systems(Startup, (startup, build_grid.after(startup)))
        .run();
}

fn startup(mut commands: Commands) {
    // Configure the grid
    let grid_settings = GridSettingsBuilder::new_2d(64, 48).chunk_size(16).build();

    // Spawn the grid used for pathfinding.
    commands.spawn(Grid::&lt;CardinalNeighborhood&gt;::new(&amp;grid_settings));
}

fn build_grid(grid: Single&lt;&amp;mut Grid&lt;CardinalNeighborhood&gt;&gt;) {
    let mut grid = grid.into_inner();

    // Let's set the position 8, 8 to a wall
    grid.set_nav(UVec3::new(8, 8, 0), Nav::Impassable);

    // The default settings set every position as passable but for demonstration let's set one
    // Nav::Passable takes a movement cost which determines how expensive it is to move to that position.
    grid.set_nav(UVec3::new(4, 4, 0), Nav::Passable(1));

    info!(&quot;Building the grid...&quot;);

    // The grid needs to be built after setting the points.
    // Building the grid will calculate the chunk entrances and cache internal paths.
    grid.build();

    info!(&quot;Grid built successfully!&quot;);
}
</code></pre></pre>
<h2 id="grid-generic-neighborhood-shorthand-types"><a class="header" href="#grid-generic-neighborhood-shorthand-types">Grid Generic Neighborhood Shorthand Types</a></h2>
<p>The following shorthand types are also available for constructing and referencing a <code>Grid::&lt;N&gt;</code>.</p>
<ul>
<li>CardinalGrid</li>
<li>CardinalGrid3d</li>
<li>OrdinalGrid</li>
<li>OrdinalGrid3d</li>
</ul>
<p>Rather than <code>Grid&lt;CardinalNeighborhood&gt;::new</code> you can use <code>CardinalGrid::new</code>.
Rather than querying <code>Single&lt;&amp;mut Grid&lt;CardinalNeighborhood&gt;&gt;</code> you can query <code>Single&lt;&amp;mut CardinalGrid&gt;</code></p>
<h2 id="quick-northstarplugin-pathfinding-system-usage"><a class="header" href="#quick-northstarplugin-pathfinding-system-usage">Quick NorthstarPlugin Pathfinding System Usage</a></h2>
<p>Using the example above we can create a system to look for entities without a path and give them a goal.</p>
<p>If you're not interested in using the built-in systems, see <a href="./pathfinding.html">Pathfinding</a> for examples.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_northstar::prelude::*;

fn spawn(mut commands: Commands) {
    let grid_settings = GridSettingsBuilder::new_2d(64, 48).chunk_size(16).build();
    // Store the spawned entity to relate entities to this grid.
    let grid_entity = commands.spawn(CardinalGrid::new(&amp;grid_settings));

    // Let's spawn a pathfinding Player agent
    commands.spawn((
        Name::new(&quot;Player&quot;),
        // AgentPos is required to position your entity in the grid.
        AgentPos(UVec3::new(4, 4, 0)),
        // Here we relate this agent to the grid we created.
        AgentOfGrid(grid_entity),
    ));
}

fn pathfind_agents(
    // The Pathfind component acts as a request to pathfind to a goal.
    query: Query&lt;Entity, Without&lt;Pathfind&gt;&gt;,
    mut commands: Commands,
) {
    for entity in &amp;query {
        // Let's request to pathfind to 7,7.
        commands.entity(entity).insert(Pathfind::new(UVec3::new(7, 7, 0)));
    }
}

fn move_player(
    mut query: Query&lt;(Entity, &amp;mut AgentPos, &amp;NextPos)&gt;
    mut commands: Commands,
) {
    for (entity, mut agent_pos, next_pos) in &amp;mut query {
        // NextPos contains the next valid position in the path.
        // Here we update just the AgentPos to keep it aligned with the grid,
        // but for real usage you would also likely update the transform for world positioning.
        agent_pos.0 = next_pos.0;

        // Remove the NextPos component and the pathfinding system will insert a new NextPos with the next position in the path.
        commands.entity(entity).remove::&lt;NextPos&gt;();
        // Once the agent reaches its goal, Pathfind will be removed.
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="grid-as-a-component"><a class="header" href="#grid-as-a-component">Grid as a Component</a></h2>
<p>Currently the plugin Pathfinding and Debug systems expect there to be only a single copy of the Grid component which means you can't currently use them if you want to support multiple grids in your project. </p>
<p>Normally it would make sense for this to be Bevy <code>Resource</code> but this decision was made so the plugin can update to support multiple grids in the future without making breaking API changes. If your project needs to support multiple pathfinding grids you can avoid using the NorthstarPlugin and NorthstarDebugPlugin and call the pathfinding functions directly on the <code>Grid</code> components for the time being.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-the-grid-with-gridsettingsbuilder"><a class="header" href="#configuring-the-grid-with-gridsettingsbuilder">Configuring the Grid with GridSettingsBuilder</a></h1>
<p>Use <code>GridSettingsBuilder</code> to generate <code>GridSettings</code> to pass to the <code>Grid</code> constructor.
You will need to call <code>build()</code> to get the returned settings to pass to <code>Grid</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy_northstar::prelude::*;

let grid_settings = GridSettingsBuilder::new_2d(128, 128)
    .chunk_size(16)
    .default_impassable()
    .add_neighbor_filter(filter::NoCornerClipping)
    .enable_collision()
    .avoidance_distance(5)
    .build();

let grid: Grid&lt;OrdinalNeighborhood&gt; = Grid::new(&amp;grid_settings);
<span class="boring">}
</span></code></pre></pre>
<h1 id="gridsettingsbuilder-configuration-breakdown"><a class="header" href="#gridsettingsbuilder-configuration-breakdown">GridSettingsBuilder Configuration Breakdown</a></h1>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<h3 id="new_2dwidth-height"><a class="header" href="#new_2dwidth-height"><code>new_2d(width, height)</code></a></h3>
<p>Request a 2d grid. The grid always uses UVec3 in the background so this is just a helper constructor to ignore Z.
<code>width</code> and <code>height</code> are the dimensions of the grid, not pixel size.</p>
<h3 id="new_3dwidth-height-depth"><a class="header" href="#new_3dwidth-height-depth"><code>new_3d(width, height, depth)</code></a></h3>
<p>Request a 3d grid. <code>depth</code> being the z dimension.</p>
<h2 id="chunk-settings"><a class="header" href="#chunk-settings">Chunk Settings</a></h2>
<h3 id="chunk_sizesize"><a class="header" href="#chunk_sizesize"><code>chunk_size(size)</code></a></h3>
<p><code>Default: 16</code></p>
<p>The grid is divided down into regions called chunks. You can configure the size of these regions with <code>chunk_size(size)</code>. Larger chunks will reduce build time and pathfinding time, while smaller chunks will create more optimal paths.</p>
<h3 id="chunk_depthsize"><a class="header" href="#chunk_depthsize"><code>chunk_depth(size)</code></a></h3>
<p><code>Default: 1</code></p>
<p>Ignore if your game is fully 2d. The chunk regions depth is determined separately. 1 is fine for fake 3d maps like isometric maps with a few height layers.</p>
<h3 id="enable_diagonal_connections"><a class="header" href="#enable_diagonal_connections"><code>enable_diagonal_connections()</code></a></h3>
<p>By default the entrances to chunks only look for other chunks that are cardinally adjacent. Enabling diagonal connections will create entrances in corners where diagonally adjacent chunks are accessible.</p>
<p>Enabling this will increase build and pathfinding time but can result in better paths if you have a noisy map.</p>
<h2 id="default-navigation-settings"><a class="header" href="#default-navigation-settings">Default Navigation Settings</a></h2>
<h3 id="default_movement_costcost"><a class="header" href="#default_movement_costcost"><code>default_movement_cost(cost)</code></a></h3>
<p><code>Default: 1</code></p>
<p>Initializes each grid cell with the set cost.</p>
<h3 id="default_impassable"><a class="header" href="#default_impassable"><code>default_impassable()</code></a></h3>
<p><code>Default: Passable</code></p>
<p>Initializes each grid cell as <code>Nav::Impassable</code>. Useful if you're procedurally generating your map and can speed up setting cells by only digging out what's needed.</p>
<h2 id="collision-settings"><a class="header" href="#collision-settings">Collision Settings</a></h2>
<h3 id="enable_collision"><a class="header" href="#enable_collision"><code>enable_collision()</code></a></h3>
<p><code>Default: Collision disabled</code></p>
<p>Enables the built-in pathfinding systems to use collision avoidance so entities with the <code>Blocking</code> component will never occupy the same position.</p>
<h3 id="avoidance_distancedistance"><a class="header" href="#avoidance_distancedistance"><code>avoidance_distance(distance)</code></a></h3>
<p><code>Default: 4</code></p>
<p>The collision avoidance system will look ahead in the path to see if any upcoming path positions might be blocked and will re-route to avoid the collision. This will set how far the system looks ahead. Longer distances will affect CPU performance.</p>
<h2 id="neighbor-settings"><a class="header" href="#neighbor-settings">Neighbor Settings</a></h2>
<h3 id="add_neighbor_filterfilter"><a class="header" href="#add_neighbor_filterfilter"><code>add_neighbor_filter(filter)</code></a></h3>
<p>Pass a <code>NeighborFilter</code> that will be applied to viable neighbors when they are precalculated. See <a href="./neighborhood/02_filters.html">Filters</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cell-navigation-data"><a class="header" href="#cell-navigation-data">Cell Navigation Data</a></h1>
<p>Each cell in the <code>Grid</code> contains navigation data that is used for pathfinding.</p>
<p>The primary way for setting the nav data is using <code>Grid::set_nav()</code>, which takes a <code>Nav</code> enum.</p>
<h3 id="cost"><a class="header" href="#cost">Cost</a></h3>
<p>&quot;Cost&quot; is a common concept in pathfinding and is used throughout the crate. It represents how difficult it is for an agent to move through a given cell. All internal pathfinding systems use cost to find the lowest-cost path to a goal, rather than the absolute shortest one.</p>
<p>You can use cost to discourage agents from entering certain areas. For example, moving through water might be allowed but is assigned a higher cost so that agents avoid that route unless necessary. Another use case would be movement budgets like action points. Each tile could represent a certain number of action points a move costs.</p>
<h2 id="nav"><a class="header" href="#nav">Nav</a></h2>
<p><code>Nav</code> is the enum used to set cell navigation data. You can set it with <code>Grid::set_nav()</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set 1, 1, 1 to a wall
grid.set_nav(UVec3::new(1, 1, 1), Nav::Impassable)
// Set 2, 2, 2 as &quot;walkable&quot; with a cost of 4.
grid.set_nav(UVec3::new(2, 2, 2), Nav::Passable(4))
// Set 3, 3, 3 as a portal that warps the agent to 7, 7, 7 with a cost of 1,
// one_way is set to true which means a reverse portal at the target will not be created.
grid.set_nav(UVec3::new(3, 3, 3), Nav::Portal(Portal::to(UVec3::new(7, 7, 7), 1, true))) 
<span class="boring">}
</span></code></pre></pre>
<h3 id="navimpassable"><a class="header" href="#navimpassable"><code>Nav::Impassable</code></a></h3>
<p>Marks the cell as impassable (e.g., a wall). Paths will never include this position.
You can default the entire grid to impassable using <code>GridSettingsBuilder::default_impassable</code>.</p>
<h3 id="navpassablemovementcost"><a class="header" href="#navpassablemovementcost"><code>Nav::Passable(MovementCost)</code></a></h3>
<p>Marks the cell as passable with a specified cost.
By default, <code>GridSettingsBuilder</code> sets all cells to passable with a cost of <code>1</code>. You can override this with <code>GridSettingsBuilder::default_cost(u32)</code>.</p>
<p>This is the main variant used for standard walkable terrain.</p>
<h3 id="navportalportal"><a class="header" href="#navportalportal"><code>Nav::Portal(Portal)</code></a></h3>
<p>Defines a &quot;portal&quot; that overrides normal neighborhood movement rules. See below for usage.</p>
<h2 id="portal-rampsstairs-elevators-actual-portals"><a class="header" href="#portal-rampsstairs-elevators-actual-portals">Portal: Ramps/Stairs, Elevators, Actual Portals</a></h2>
<p>Portals allow movement between positions that wouldn't normally be adjacent under standard neighborhood rules. They're often used in 2.5D tilemaps to represent elevation changes (e.g., ramps or stairs), but they can also be used for actual teleporters.</p>
<h3 id="rampstairs"><a class="header" href="#rampstairs">Ramp/Stairs</a></h3>
<p><img src="images/rampsamecell.png" alt="Ramp" /></p>
<p>In the image above, the ramp transitions the agent from Z = 0 to Z = 2, which isn’t normally allowed by OrdinalNeighborhood3d. You can create this behavior by setting a portal at the ramp tile:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Target destination for this portal, which in our case is the current tile x, y + to a height of 2.
let target_pos = UVec3::new(tile_pos.x, tile_pos.y, 2);

// Create the portal for the ramp
grid.set_nav(
    // The position of our ramp cell
    UVec3::new(tile_pos.x, tile_pos.y, 0),
    // You can set the destination to the same x,y position but change the z height
    // We'll set the cost to 2, this is arbitrary.
    Nav::Portal(Portal::to(target_pos, 2, false)),
    // As one_way is set to false, we don't need to worry about creating a reverse portal at the target
    // set_nav will handle that for you.
);
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, place the portals on tiles adjacent to the ramp:</p>
<p><img src="images/ramp.png" alt="RampAlternative" /></p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Have the bottom adjacent cell to the ramp portal to the top adjacent cell to the ramp.
grid.set_nav(UVec3::new(0, 0, 0), Nav::Portal(Portal::to(2, 0, 2), 1, false))
<span class="boring">}
</span></code></pre></pre>
<h3 id="teleporting"><a class="header" href="#teleporting">Teleporting</a></h3>
<p>To create a teleporter, set the portal destination to any arbitrary map position. You can make it one-way by not adding a reverse portal:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Let's say the current_tile is at 5, 5, 4
let current_tile = UVec3::new(5, 5, 4);

grid.set_nav(
    current_tile,
    /// This cell can be used as a warp to 45, 45, 0 at a cost of 1.
    Nav::Portal(Portal::to(UVec3::new(45, 45, 0), 1, true))
)
<span class="boring">}
</span></code></pre></pre>
<img src="images/portal.png" width="500"/>
<h3 id="animations-for-portals"><a class="header" href="#animations-for-portals">Animations For Portals</a></h3>
<p>You'll likely want to animate transitions when agents use jumps, ramps, or portals.</p>
<p>The <code>Path::next()</code> method is useful for this. It returns the next position in the path, which you can compare to the agent's current tile position. This lets you determine what kind of tile the agent is moving into such as a portal, a ramp. Or just test if the Z depth changes and trigger a jump animation.</p>
<p>You can also get the agents current cell navigation data, for example, test if the agent is standing on a portal:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(Nav::Portal(portal)) = grid.nav(position.0) {
    // Trigger some warping particle fx.
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grid-updates"><a class="header" href="#grid-updates">Grid Updates</a></h1>
<p>You can modify the navigation data of individual cells at runtime using <code>Grid::set_nav()</code>. 
After making changes, you <strong>must</strong> call <code>Grid::build()</code> to update the internal state.</p>
<p>When <code>Grid::set_nav()</code> is called, the affected chunk and its adjacent chunks are automatically marked as dirty. During the next <code>Grid::build()</code> call, only those dirty chunks are rebuilt. If the default parallel feature is enabled, chunk rebuilds are performed in parallel for better performance.</p>
<p>Calling any of the <code>Grid</code> pathfinding methods on a dirty grid will log an error and return <code>None</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust no-run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if input.just_pressed(MouseButton::Right) {
    if let Some(position) = clicked_tile {
        let mut grid = grid.into_inner();

        if let Some(nav) = grid.nav(position) {
            if !matches!(nav, Nav::Impassable) {
                // If the cell is passable, we set it to impassable.
                grid.set_nav(position, Nav::Impassable);
            } else {
                // If the cell is impassable, we set it to passable with a cost of 1.
                grid.set_nav(position, Nav::Passable(1));
            }
        } else {
            return;
        }
        // You must call `build` after modifying the grid to update the internal state.
        grid.build();
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<p>Rebuilding a single chunk takes approximately <strong>0.2ms</strong> on modern systems. Note that updating a cell in a single chunk may require updating neighboring chunks if it touches an edge. If you enable <code>GridSettingsBuilder::diagonal_connections()</code> or use an ordinal <code>Neighborhood</code>, the number of adjacent chunks needing rebuilds may increase.</p>
<ul>
<li>
<p>With the default <code>parallel</code> feature enabled, multiple dirty chunks can often be rebuilt in the same frame with a ~35% speedup.</p>
</li>
<li>
<p>If <code>parallel</code> is disabled (e.g. for WASM), rebuilding a large number of chunks sequentially may exceed your frame budget. In that case, consider:</p>
<ul>
<li>
<p>Limiting updates to small, localized areas per frame.</p>
</li>
<li>
<p>Spreading updates across multiple frames.</p>
</li>
<li>
<p>Adjusting chunk size to find the best performance fo your use case.</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pathfinding-with-built-in-systems"><a class="header" href="#pathfinding-with-built-in-systems">Pathfinding With Built-In Systems</a></h1>
<h2 id="pathfind-and-agentpos-components"><a class="header" href="#pathfind-and-agentpos-components">Pathfind and AgentPos Components</a></h2>
<p>To use the <code>NorthstarPlugin</code> pathfinding systems, insert a <code>Pathfind</code> and <code>AgentPos</code> on the entity you want to pathfind.
You will need to maintain the grid position in <code>AgentPos</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands
    .spawn((
        Name::new(&quot;Player&quot;),
        // Request a path to 8,8
        Pathfind::new(UVec3::new(8, 8, 0)),
        // The entities current position in the grid
        AgentPos(UVec3::new(4, 4, 0))
        Blocking, // Insert the Blocking component if using collision and this entity should block others.
    ));
<span class="boring">}
</span></code></pre></pre>
<p>There are also shorthand constructors for creating <code>Pathfind</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If you're on a 2d grid you can use `new_2d()` without having to create a new UVec3. 
Pathfind::new_2d(8, 8)
// Same with 3d
Pathfind::new_3d(8, 8, 4)
<span class="boring">}
</span></code></pre></pre>
<h3 id="pathfind-configuration"><a class="header" href="#pathfind-configuration">Pathfind Configuration</a></h3>
<p>Pathfind has configuration options you can set by chaining.</p>
<h4 id="modemode"><a class="header" href="#modemode"><code>mode(mode)</code></a></h4>
<p><code>Default: PathfindMode::Refined</code> </p>
<p>Use this to set the desired algorithm to find the goal. Ex: <code>Pathfind::new_2d(8, 8).mode(PathfindMode::AStar)</code>.
See below for a list of <code>PathfindMode</code>s and their description.</p>
<h4 id="partial"><a class="header" href="#partial"><code>partial()</code></a></h4>
<p><code>Default: Not enabled</code></p>
<p>Apply <code>.partial()</code> to request an incomplete path if the goal is not reachable. Ex: <code>Pathfind::new_2d(4, 4).mode(PathfindMode::Astar).partial()</code>.</p>
<p>Will only work with AStar and ThetaStar. Refined, Coarse, and Waypoints use HPA* which doesn't handle partial paths easily.</p>
<h4 id="search_regionnavregion"><a class="header" href="#search_regionnavregion"><code>search_region(NavRegion)</code></a></h4>
<p>Provide a <code>NavRegion</code> and it will limit the pathfinding search so that it will be constrained inside the region. </p>
<h4 id="max_distanceu32"><a class="header" href="#max_distanceu32"><code>max_distance(u32)</code></a></h4>
<p>Sets a maximum search distance from the start position.<br />
Useful for AI when searching for nearby goals or objects to prevent excessive searching if the goal cannot be reached.</p>
<h2 id="nextpos"><a class="header" href="#nextpos">NextPos</a></h2>
<p>The pathfind system detects entities with a changed <code>Pathfind</code> component. It then runs the pathfinding algorithm and, if a valid path is found, inserts the next step as a <code>NextPos</code> component.</p>
<p>You should consume the <code>NextPos</code> component by moving the entity accordingly and then removing the component afterward. In a subsequent frame, the next_position system will insert the next <code>NextPos</code> if the path is not yet complete.</p>
<p>If collision avoidance is enabled, the next_position system will also handle local avoidance. It may adjust the path if another entity is blocking the current path within the configured avoidance_distance (as set in <code>GridSettingsBuilder</code>).</p>
<p>See <a href="pathfinding/./grid_settings.html">Grid Settings</a> for more information on enabling and configuring collision.</p>
<p>Example movement system:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn movement(
    mut commands: Commands,
    mut query: Query&lt;(Entity, &amp;mut AgentPos, &amp;NextPos)&gt;,
) {
    for (entity, mut agent_pos, next_pos) in &amp;mut query {
        // Set the entities GridPos to the NextPos UVec3.
        agent_pos.0 = next_pos.0;

        // Update the entities translation
        let translation = Vec3::new(
            next.0.x as f32 * 32.0, // Assuming tiles are 32x32
            next.0.y as f32 * 32.0,
            0.0
        );

        commands.entity(entity)
            .insert(Transform::from_translation(translation))
            .remove::&lt;NextPos&gt;();
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="pathfindingcollision-marker-components"><a class="header" href="#pathfindingcollision-marker-components">Pathfinding/Collision Marker Components</a></h2>
<h3 id="pathfindingfailed"><a class="header" href="#pathfindingfailed"><code>PathfindingFailed</code></a></h3>
<p>This component is inserted into an entity if a path to the desired goal cannot be found.
You will want to create a system that determines how to handle the failure in a way unique to your game.</p>
<h3 id="avoidancefailed"><a class="header" href="#avoidancefailed"><code>AvoidanceFailed</code></a></h3>
<p>This component is inserted when collision avoidance is enabled and the entity cannot find a path around a local <code>Blocking</code> entity.</p>
<p>The <code>reroute_path</code> system will automatically attempt to compute a new full HPA* path to resolve the issue in the next frame. You may also choose to handle this yourself in a custom system.</p>
<h3 id="reroutefailed"><a class="header" href="#reroutefailed"><code>RerouteFailed</code></a></h3>
<p>This component is added when all attempts to resolve a collision-related pathing issue have failed, meaning no viable path to the goal exists at the moment or the entity is stuck.</p>
<p>You must handle this case in your own system — for example, by:</p>
<ul>
<li>Selecting a new goal</li>
<li>Waiting and retrying after a delay</li>
<li>Alerting the player/user</li>
</ul>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_pathfind_failed(
    mut commands: Commands,
    mut query: Query&lt;(Entity, &amp;Name, &amp;Pathfind), With&lt;PathfindingFailed&gt;&gt;,
) {
    for (entity, name, path) in &amp;mut query {
        log::warn!(&quot;{} cannot find a route to {}!&quot;, name, path.goal);

        let new_goal = locate_new_cheese();

        commands
            .entity(entity)
            .insert(Pathfind::new(new_goal))
            .remove::&lt;PathfindingFailed&gt;();
    }
}

fn handle_reroute_failed(
    mut commands: Commands,
    mut query: Query&lt;Entity, With&lt;RerouteFailed&gt;&gt;,
) {
    for entity in &amp;mut query {
        let some_new_goal = UVec3::new(3, 30, 0); // Just some random new goal

        commands
            .entity(entity)
            .insert(Pathfind::new(some_new_goal))
            .remove::&lt;RerouteFailed&gt;();
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="default-algorithm"><a class="header" href="#default-algorithm">Default Algorithm</a></h2>
<p>By default, the pathfinding plugin systems use Refined HPA*.
You can change this by setting a different <code>default_mode</code> in the plugin settings:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::new()
    .insert_resource(NorthstarPluginSettings {
        pathfind_settings: PathfindSettings {
            default_mode: PathfindMode::AStar,
        },
        ..Default::default(),
    })
<span class="boring">}
</span></code></pre></pre>
<h2 id="pathingset"><a class="header" href="#pathingset">PathingSet</a></h2>
<p>The <code>NorthstarPlugin</code> pathfinding systems run in their own system set named <code>PathingSet</code>.</p>
<p>You can use the set to ensure that your systems dealing with pathfinding and entity movement happen before or after the pathing systems.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>app.add_systems(Update, move_pathfinders.before(PathingSet));
<span class="boring">}
</span></code></pre></pre>
<h2 id="staggering-pathfinding-in-the-northstarplugin-systems"><a class="header" href="#staggering-pathfinding-in-the-northstarplugin-systems">Staggering Pathfinding in the <code>NorthstarPlugin</code> Systems</a></h2>
<p>The systems provided by <code>NorthstarPlugin</code> are designed to stagger how many agents can process pathfinding and collision avoidance in a single frame.</p>
<p>By default, both limits are set to <code>128</code> agents per frame. This may be too high if you actually have that many active agents. On the other hand, setting it too low can cause noticeable delays, with agents appearing to sit idle. You’ll want to tune these values based on your game’s performance needs.</p>
<p>Currently the <code>reroute_path</code> system that attempts to reroute agents that have a failed path that local collision avoidance is unable to resolve can still cause stutter. In a future update it will be moved into any async call.</p>
<p>To override the default settings, insert the <code>NorthstarPluginSettings</code> resource into your app:</p>
<pre><pre class="playground"><code class="language-rust no-run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>App::new()
    .insert_resource(NorthstarPluginSettings {
        max_pathfinding_agents_per_frame: 16,
        max_collision_avoidance_agents_per_frame: 16,
    })
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="available-modes--algorithms"><a class="header" href="#available-modes--algorithms">Available Modes / Algorithms</a></h1>
<h2 id="pathfindmode"><a class="header" href="#pathfindmode">PathfindMode</a></h2>
<p>The pathfinding algorithm enum. Current options are:</p>
<h3 id="grid-movement-modes"><a class="header" href="#grid-movement-modes">Grid Movement Modes</a></h3>
<p>These modes return paths that keep the agent’s movement constrained to the grid. Every position in the path is adjacent to the next.</p>
<h4 id="pathfindmoderefined"><a class="header" href="#pathfindmoderefined"><code>PathfindMode::Refined</code></a></h4>
<h5 id="this-is-the-default-algorithm"><a class="header" href="#this-is-the-default-algorithm">This is the default algorithm</a></h5>
<p>Gets a high level path to the goal at the chunk level. If a path is found, the path is iterated over with a line of sight / tracing algorithm to attempt to create the shortest path to the goal. The refinement is more expensive than the HPA* algorithm but not nearly as expensive as using A*.</p>
<p><em>Manual call</em>: <code>Grid::pathfind()</code>.</p>
<h4 id="pathfindmodecoarse"><a class="header" href="#pathfindmodecoarse"><code>PathfindMode::Coarse</code></a></h4>
<p>Returns the unrefined HPA* path pulled from the cached entrance paths. This will not return the path with the least steps to the goal but is extremely fast to generate. It's great for natural paths NPCs might use to move around a building for example.</p>
<p><em>Manual call</em>: <code>Grid::pathfind_coarse()</code>.</p>
<h4 id="pathfindmodeastar"><a class="header" href="#pathfindmodeastar"><code>PathfindMode::AStar</code></a></h4>
<p>This is standard A* pathfinding. It's very expensive for long distance goals on large maps but is still useful for very short distances or when you're concerned with the absolute shortest path. A good use would be movement where action points are subtracted based on number of moves.</p>
<p><em>Manual call</em>: <code>Grid::pathfind_astar()</code>.</p>
<h3 id="any-angle-modes"><a class="header" href="#any-angle-modes">Any Angle Modes</a></h3>
<p>Any-angle modes return the path as a series of waypoint segments. Each waypoint marks the start or end of a straight-line segment that can be traversed without intersecting any obstacles. This is intended for freeform movement where the agent is not constrained to follow the grid.</p>
<p>You will need to handle your own collision when using Any-Angle modes. The typical use case for any-angle would be to use a physics engine to handle collision and add create a local steering avoidance system to avoid other colliding agents and walls.</p>
<blockquote>
<p><strong>⚠️ Warning</strong>
The cost of an any-angle path is a good estimate but does not account for the exact cost of every grid cell the agent may or may not pass through between waypoints.</p>
</blockquote>
<h4 id="pathfindmodewaypoints"><a class="header" href="#pathfindmodewaypoints"><code>PathfindMode::Waypoints</code></a></h4>
<p>Very fast HPA* any-angle pathfinding that returns only the essential waypoints instead of the full step-by-step path. It uses the standard HPA* algorithm, but during the refinement stage it outputs only the waypoints rather than expanding every intermediate step.</p>
<p><em>Manual call</em>: <code>Grid::pathfind_waypoints()</code>.</p>
<h4 id="pathfindmodethetastar"><a class="header" href="#pathfindmodethetastar"><code>PathfindMode::ThetaStar</code></a></h4>
<p>An expensive but near-optimal any-angle algorithm. It produces paths similar to PathfindMode::Waypoints, but can sometimes yield slightly shorter results. This is a lazy Theta* implementation, which calculates line-of-sight for all neighbors during the search, making it significantly more costly to compute.</p>
<p><em>Manual call</em>: <code>Grid::pathfind_thetastar()</code>.</p>
<h3 id="limited-search"><a class="header" href="#limited-search">Limited Search</a></h3>
<p>There is also an extra AStar algorthm that is currently only available by manually calling it on the grid <code>Grid::pathfind_astar_radius()</code>. This will run AStar pathfinding limited to a u32 radius around the starting point.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-path-component--struct"><a class="header" href="#the-path-component--struct">The <code>Path</code> Component / Struct</a></h1>
<p>The <code>Path</code> component will be inserted to an entity when after a path is found. It is also returned when calling the manual pathfinding methods on <code>Grid</code>.</p>
<p>You can use it draw paths in your game, for example when highlighting tiles for a path in a turn based game.</p>
<p>There are a few notable methods on <code>Path</code>.</p>
<h3 id="path---uvec3"><a class="header" href="#path---uvec3"><code>path() -&gt; &amp;[UVec3]</code></a></h3>
<p>Returns an array of all positions in the path.</p>
<h3 id="cost---u32"><a class="header" href="#cost---u32"><code>cost() -&gt; u32</code></a></h3>
<p>The full cost of the path. It is the sum of all movement costs for each cell in the grid that the path crosses over.</p>
<h3 id="len---usize"><a class="header" href="#len---usize"><code>len() -&gt; usize</code></a></h3>
<p>The total number of positions <strong>currently</strong> in the path.</p>
<h3 id="next---optionuvec3"><a class="header" href="#next---optionuvec3"><code>next() -&gt; Option&lt;UVec3&gt;</code></a></h3>
<p>Returns the next position in the path without removing it. Very useful in animation systems to play a different animation based on tile transition for example, playing a jumping animation when the next position is a higher z depth.</p>
<h3 id="pop---optionuvec3"><a class="header" href="#pop---optionuvec3"><code>pop() -&gt; Option&lt;UVec3&gt;</code></a></h3>
<p>Removes and returns the next position of the path.</p>
<h4 id="see-the-crate-docs-for-more-a-couple-of-notable-ones-are-reverse-and-translate_byoffset"><a class="header" href="#see-the-crate-docs-for-more-a-couple-of-notable-ones-are-reverse-and-translate_byoffset">See the crate docs for more. A couple of notable ones are <code>reverse()</code> and <code>translate_by(offset)</code></a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-pathfinding"><a class="header" href="#manual-pathfinding">Manual Pathfinding</a></h1>
<p>You don't need to use the pathfinding systems in the <code>NorthstarPlugin</code> in order to take advantage of this crate. </p>
<p>You can use both, or choose to not add the <code>NorthstarPlugin</code> and call the pathfinding functions completely manually.</p>
<p>If you don't use <code>NorthstarPlugin</code> you'll need to maintain your own <code>BlockingMap</code> or <code>HashMap&lt;UVec3, Entity&gt;</code> to pass to the <code>pathfind</code> function to provide it a list of blocked positions.</p>
<p>All pathfinding can be done calling the <code>pathfind</code> method on the the <code>Grid</code> component.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn manual_pathfind(
    mut commands: Commands,
    player: Single&lt;(Entity, &amp;AgentPos, &amp;MoveAction), With&lt;Player&gt;&gt;,
    grid: Single&lt;&amp;CardinalGrid&gt;,
    // If using the plugin you can use the BlockingMap resource for an auto-updated blocking list.
    blocking: Res&lt;BlockingMap&gt;,
) {
    let grid = grid.into_inner();
    let (player, grid_pos, move_action) = player.into_inner();

    let path = grid.pathfind(
        PathfindArgs::new(grid_pos.0, move_action.0)
    );

    info!(&quot;Path {:?}&quot;, path);
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Grid</code> pathfinding methods return an <code>Option&lt;Path&gt;</code>. <code>None</code> will be returned if no viable path is found.</p>
<h2 id="pathfindargs"><a class="header" href="#pathfindargs">PathfindArgs</a></h2>
<p><code>Grid::pathfind</code> takes <code>PathfindArgs</code> which works just like the <code>Pathfind</code> component to build the arguments for pathfinding.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let args = PathfindArgs::new(start, goal).astar().max_distance(50);
<span class="boring">}
</span></code></pre></pre>
<h4 id="newstart-uvec3-goal-uvec3---self"><a class="header" href="#newstart-uvec3-goal-uvec3---self"><code>new(start: UVec3, goal: UVec3) -&gt; Self</code></a></h4>
<p>Construct <code>PathfindArgs</code> with the starting position and the goal position.</p>
<h3 id="modes-algorithms"><a class="header" href="#modes-algorithms">Modes (Algorithms)</a></h3>
<ul>
<li>
<p><code>refined()</code> (default)
Uses HPA* and then refines the path with line tracing. Produces smooth, efficient paths.</p>
</li>
<li>
<p><code>coarse()</code>
Uses cached HPA* cluster data only. Extremely fast, but paths may be less accurate.</p>
</li>
<li>
<p><code>waypoints()</code>
Returns only the waypoints needed to navigate around obstacles. Useful for continuous movement systems (e.g., steering behaviors).</p>
</li>
<li>
<p><code>astar()</code>
Runs a standard grid-based A* search.</p>
</li>
<li>
<p><code>thetastar()</code>
Runs the Theta* any-angle algorithm. Produces fluid, natural-looking paths by cutting corners where possible.</p>
</li>
</ul>
<p>Or, set directly with:</p>
<pre><code>args.mode(PathfindMode::AStar);
</code></pre>
<h3 id="search-limits"><a class="header" href="#search-limits">Search Limits</a></h3>
<p>You can constrain how far or where the algorithm searches:</p>
<ul>
<li>
<p><code>partial()</code>
If the goal cannot be reached, returns the closest path instead of failing.
Note that this doesn't work with the default refined (HPA*) or waypoints algorithm as HPA* doesn't handle partial pathing well. You'll want to use this only with AStar or ThetaStar.</p>
</li>
<li>
<p><code>max_distance(n: u32)</code>
Stops searching after the set distance from the start. No path is returned if the goal is farther away. </p>
</li>
<li>
<p><code>search_region(region: NavRegion)</code>
Restricts the search to a given region.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neighborhoods"><a class="header" href="#neighborhoods">Neighborhoods</a></h1>
<h3 id="cardinalneighborhood"><a class="header" href="#cardinalneighborhood">CardinalNeighborhood</a></h3>
<p>Allows movement in the four cardinal directions on a 2D plane: <strong>North, East, South, and West</strong>.</p>
<p><img src="neighborhood/../images/cardinalneighborhood.png" alt="Cardinal Directions" /></p>
<h3 id="cardinalneighborhood3d"><a class="header" href="#cardinalneighborhood3d">CardinalNeighborhood3d</a></h3>
<p>Allows movement in all six cardinal directions in 3D space: <strong>North, East, South, West, Up, and Down</strong>.
This 3D neighborhood is also well-suited for 2D tilemap games with height layers, such as isometric maps.</p>
<p><img src="neighborhood/../images/cardinalneighborhood3d.png" alt="Cardinal3d Directions" /></p>
<h3 id="ordinalneighborhood"><a class="header" href="#ordinalneighborhood">OrdinalNeighborhood</a></h3>
<p>Extends cardinal movement by allowing diagonal movement in addition to the standard directions.</p>
<p><img src="neighborhood/../images/ordinalneighborhood.png" alt="Ordinal Directions" /></p>
<h3 id="ordinalneighborhood3d"><a class="header" href="#ordinalneighborhood3d">OrdinalNeighborhood3d</a></h3>
<p>Extends <code>CardinalNeighborhood3d</code> by allowing diagonal movement in all three dimensions—e.g., North-East-Up—for a total of 26 possible directions.</p>
<p>Like <code>CardinalNeighborhood3d</code>, this is also useful for 2D tilemap games with height layers, such as isometric maps.</p>
<p>A <code>NeighborFilter</code> is available to restrict diagonal movement to only within the same depth level, reducing the number of directions from 26 to 14. See <a href="neighborhood/./02_filters.html">Filters</a> for more details.</p>
<h2 id="implementing-the-neighborhood-trait"><a class="header" href="#implementing-the-neighborhood-trait">Implementing the Neighborhood Trait</a></h2>
<p>While you <em>can</em> implement your own Neighborhood, it is not currently recommended.</p>
<p>To support neighbor caching, each grid cell stores its neighbors in a u32 bitmask, which limits the system to 26 directions. The provided built-in neighborhoods already cover all of these directions.</p>
<p>Switching to a per-cell <code>Vec</code> or <code>HashMap</code> of neighbors would drastically increase memory usage—potentially several gigabytes on large maps (e.g., 1024×1024x4 grids).</p>
<p>Before implementing a custom Neighborhood, check whether a built-in <a href="neighborhood/./02_filters.html">Filter</a> already provides the neighbor generation behavior you need, or consult the documentation for creating a custom filter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filters"><a class="header" href="#filters">Filters</a></h1>
<p><code>NeighborFilter</code>s can be applied during the stage when neighbors are calculated and cached. There are a few built-in ones but you can also implement the <code>NeighborFilter</code> trait yourself to create new ones.</p>
<p>Filters can be chained and they will be applied in the order that they are added to <code>GridSettingsBuilder</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let grid_settings = GridSettingsBuilder::new_3d(64, 64, 4)
    .chunk_size(4)
    .add_neighbor_filter(filter::NoCornerClipping)
    .add_neighbor_filter(filter::DisallowZDiagonalMovement)
    .build();
<span class="boring">}
</span></code></pre></pre>
<h2 id="nocornercutting"><a class="header" href="#nocornercutting">NoCornerCutting</a></h2>
<p>Forces cardinal movement around impassable (wall) cells by preventing diagonal movement around ANY adjacent impassable (wall) cell.
Don't use with <code>NoCornerClipping</code> as this filter already covers clipping through corners.</p>
<p>Apply to <code>GridSettingsBuilder</code> with <code>.add_neighbor_filter(filter::NoCornerCutting)</code>.</p>
<p><img src="neighborhood/../images/nocornercutting.png" alt="NoCornerCutting" /></p>
<h2 id="nocornercuttingflat"><a class="header" href="#nocornercuttingflat">NoCornerCuttingFlat</a></h2>
<p>Works the same as <code>NoCornerCutting</code> with the exception that paths can jump z depth diagonally around corners. <em>This is an ideal filter to use in 2.5D games</em>. You may want to disable agents from cutting diagonally around corners so your sprites don't clip through wall corners causing y sorting glitches, but retain the ability for your agents to jump to higher heights.</p>
<p><img src="neighborhood/..//images/nocornercuttingflatnoz.png" alt="No corner cutting is allowed in the same depth" />
<img src="neighborhood/..//images/nocornercuttingflatyesz.png" alt="Corner cutting is allowed to different depths" /></p>
<h2 id="nocornerclipping"><a class="header" href="#nocornerclipping">NoCornerClipping</a></h2>
<p>Prevents diagonal movement from clipping through impassable (wall) corners.
Don't use with <code>NoCornerCutting</code> as <code>NoCornerCutting</code> already handles this case.</p>
<p>Apply to <code>GridSettingsBuilder</code> with <code>.add_neighbor_filter(filter::NoCornerClipping)</code>.</p>
<p><img src="neighborhood/../images/nocornerclipping.png" alt="NoCornerClipping" /></p>
<h2 id="disallowzdiagonalmovement"><a class="header" href="#disallowzdiagonalmovement">DisallowZDiagonalMovement</a></h2>
<p>The <code>OrdinalNeighborhood3d</code> neighborhood allows diagonal movement along the Z axis.
If this isn't desired you can apply the <code>DisallowZDiagonalMovement</code> filter and it will limit diagonal movement to only cells on the same depth while still allowing Up and Down movement. </p>
<h1 id="implementing-your-own-filter"><a class="header" href="#implementing-your-own-filter">Implementing Your Own Filter</a></h1>
<p>TODO, for now please see <code>filters.rs</code> in the source.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigation-masks"><a class="header" href="#navigation-masks">Navigation Masks</a></h1>
<p>Navigation masks are an advanced feature let you change the grid cell cost and impassability per agent on a per-call basis.</p>
<h2 id="navigation-mask-layers"><a class="header" href="#navigation-mask-layers">Navigation Mask Layers</a></h2>
<p>A <code>NavMaskLayer</code> defines a layer of navigation data masks. Layers are then combined in <code>NavMask</code>. This allows you to represent special conditions (e.g., water tiles, faction boundaries) and assign them to individual agents through masks.</p>
<p>Most <code>NavMaskLayer</code> methods require a reference to a <code>Grid</code> to define bounds for caching data.</p>
<h3 id="navmasklayerinsert_maskgrid-pos-mask"><a class="header" href="#navmasklayerinsert_maskgrid-pos-mask"><code>NavMaskLayer::insert_mask(grid, pos, mask)</code></a></h3>
<p>Set a mask at a single cell.</p>
<h3 id="navmasklayerinsert_region_fillgrid-region-mask"><a class="header" href="#navmasklayerinsert_region_fillgrid-region-mask"><code>NavMaskLayer::insert_region_fill(grid, region, mask)</code></a></h3>
<p>Fill an entire region with the same mask.</p>
<h3 id="navmasklayerinsert_region_outlinegrid-region-mask"><a class="header" href="#navmasklayerinsert_region_outlinegrid-region-mask"><code>NavMaskLayer::insert_region_outline(grid, region, mask)</code></a></h3>
<p>Apply a mask to the outline of a region. Useful for constraining agents with <code>NavCellMask::ImpassableOverride</code>.</p>
<h3 id="navmasklayerinsert_hashmapgrid-masksuvec3-navcellmask"><a class="header" href="#navmasklayerinsert_hashmapgrid-masksuvec3-navcellmask"><code>NavMaskLayer::insert_hashmap(grid, masks&lt;UVec3, NavCellMask&gt;)</code></a></h3>
<p>Populate the layer from a <code>HashMap</code> of positions and masks.</p>
<h3 id="navmasklayerinsert_hashsetgrid-masksuvec3-mask"><a class="header" href="#navmasklayerinsert_hashsetgrid-masksuvec3-mask"><code>NavMaskLayer::insert_hashset(grid, masks&lt;UVec3&gt;, mask)</code></a></h3>
<p>Apply the same mask to all positions in the set.</p>
<h3 id="navmasklayerclear"><a class="header" href="#navmasklayerclear"><code>NavMaskLayer::clear()</code></a></h3>
<p>Remove all data from the layer including the cache.</p>
<p>See <a href="navigation_masks.html#navcellmask">NavCellMask</a> for mask options.</p>
<blockquote>
<p>⚠️ Arc Result
<code>NavMaskLayer</code> is an <code>Arc&lt;Mutex&gt;</code> wrapper so it can be shared in Bevy systems.<br />
All methods return a <code>Result</code>. Errors are returned as <code>String</code> if the data lock fails.</p>
</blockquote>
<h3 id="example-creating-a-navigation-mask-layer"><a class="header" href="#example-creating-a-navigation-mask-layer">Example: Creating a navigation mask layer</a></h3>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let layer = NavMaskLayer::new();
layer.insert_region_fill(
    &amp;grid,
    NavRegion::new(UVec3::new(0, 0, 0), UVec3::new(10, 10, 10)),
    NavCellMask::ModifyCost(5),
).ok();
<span class="boring">}
</span></code></pre></pre>
<h2 id="navigation-mask"><a class="header" href="#navigation-mask">Navigation Mask</a></h2>
<p>A <code>NavMask</code> combines one or more layers and is used during pathfinding or passed in for manual pathfinding calls.
Masks can be shared across agents or created per agent.</p>
<p>Layers are processed in order added with the last layer modifying last.</p>
<blockquote>
<p>If a cell is impassable in the grid or in any layer with <code>NavCellMask::ImpassableOverride</code>, the cell is regarded as impassable. Because neighbors are precomputed on the grid it is not currently possible to take an impassable grid cell and make it passable. If such behavior is desired, one strategy would be to make it passable on the grid and apply an impassable mask cell for your agents.</p>
</blockquote>
<p><code>NavMask</code> also includes a cache for mask HPA* lookups. See <a href="navigation_masks.html#performance-notes">Performance Notes</a>.</p>
<ul>
<li>
<p><code>NavMask::add_layer(NavMaskLayer)</code>
Adds a layer on top of the <code>NavMask</code>. This clears the cache in <code>NavMask</code>.</p>
</li>
<li>
<p><code>NavMask::with_additional_layer(NavMaskLayer)</code>
Create a copy of a <code>NavMask</code> adding an additional <code>NavMaskLayer</code> on top. Useful if you have a common <code>NavMask</code> for your agents and just need to add a layer for a single agent.</p>
</li>
<li>
<p><code>NavMask::flatten()</code>
Merges all of the layers in the mask to a single layer. If you start running into performance issues with masks with a large number of layers this should be useful.</p>
</li>
<li>
<p><code>NavMask::clear()</code>
Clears all the layers and cached data from the mask.</p>
</li>
</ul>
<blockquote>
<p>⚠️ Arc Result
<code>NavMask</code> is an <code>Arc&lt;Mutex&gt;</code> wrapper.
All methods return a <code>Result</code>. Errors are returned as <code>String</code> if the data lock fails.</p>
</blockquote>
<h3 id="example-creating-a-navmask"><a class="header" href="#example-creating-a-navmask">Example: Creating a NavMask</a></h3>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let layer = NavMaskLayer::new();
layer.insert_region_fill(
    &amp;grid,
    NavRegion::new(UVec3::new(0, 0, 0), UVec3::new(10, 10, 10)),
    NavCellMask::ModifyCost(5),
).ok();

let mask = NavMask::new();
mask.add_layer(layer).ok();
<span class="boring">}
</span></code></pre></pre>
<h2 id="navcellmask"><a class="header" href="#navcellmask">NavCellMask</a></h2>
<p><code>NavCellMask</code> is an enum  has two options you can use to layer navigation data.
Currently it supports:</p>
<ul>
<li>
<p><code>NavCellMask::ImpassableOverride</code>: Will set the cell to impassable. Setting this for a cell on any layer will make the cell impassable no matter what any of the other layers are set to.</p>
</li>
<li>
<p><code>NavCellMask::ModifyCost(i32)</code>: The i32 past can be used to add or subtract to the overall cost of the cell. For example if you wanted water cells to cost more for infantry but not vehicles you could create a mask for the infanty units that uses ModifyCost(5) for example.</p>
</li>
</ul>
<h2 id="using-masks-in-pathfinding"><a class="header" href="#using-masks-in-pathfinding">Using Masks in Pathfinding</a></h2>
<p>Use the <code>AgentMask</code> component to associate a mask with a specific entity when using the plugin systems. 
Because <code>NavMask</code> is an <code>Arc</code> wrapper, it can be cloned without duplicating the data.</p>
<p>Using the Plugin Pathfinding systems:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mask = NavMask::new();

commands
    .entity(player)
    .insert((
        Pathfind::new(UVec3::new(8, 8, 0),
        AgentMask(mask.clone()),
    ));
<span class="boring">}
</span></code></pre></pre>
<p>In direct manual pathfinding calls you can pass the mask with <code>PathfindArgs::mask</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let grid_settings = GridSettingsBuilder::new_2d(16, 16).build();
let grid = CardinalGrid::new(&amp;grid_settings);

let mask = NavMask::new();

let path = grid.pathfind(
    PathfindArgs::new(UVec3::new(0, 0, 0), UVec3::new(7, 7, 0))
        .mask(mask.clone())
);
<span class="boring">}
</span></code></pre></pre>
<h2 id="debugging-navmask"><a class="header" href="#debugging-navmask">Debugging NavMask</a></h2>
<p>You can debug a NavMask using <code>DebugGrid</code>. See <a href="./debugging.html">Debugging</a> for more information on setting up <code>DebugGrid</code>.</p>
<p>Example </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Resource)]
struct MyNavMasks(HashMap&lt;String, NavMask&gt;);

fn apply_debug_mask(debug_grid: Single&lt;&amp;mut DebugGrid&gt;, masks: Res&lt;MyNavMasks&gt;) {
    let mut debug_grid = debug_grid.into_inner();

    let mask = masks.0.get(&quot;example_mask&quot;).unwrap();
    debug_grid.set_debug_mask(mask.clone());
    // In order to view the debugged navigation masks, you'll need to enable debug cell gizmos
    debug_grid.set_draw_cells(true);

    // You can later clear the debug mask with:
    debug_grid.clear_debug_mask();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="performance-notes-1"><a class="header" href="#performance-notes-1">Performance Notes</a></h2>
<p>Adding a navigation mask to a pathfinding call will decrease the performance of the pathfinding. A navigation mask used in HPA* (Refined, Waypoint) pathfinding will cache any look ups that are done for future use. After a certain usage in HPA* the cost will greatly decrease.</p>
<p>Every change to the mask will currently clear the cache. You may want to avoid updating masks too frequently if you find you're running into performance issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-the-grid-component"><a class="header" href="#debugging-the-grid-component">Debugging the Grid component</a></h1>
<p>The <code>NorthstarDebugPlugin</code> adds systems that can be enabled to draw gizmos to display the following:</p>
<ul>
<li>Chunk grid: Grid outline of where the chunks are</li>
<li>Entrances: Calculated entrances at the boundaries of the chunks</li>
<li>Cached internal paths: Cached paths inside the chunk between its own entrances.</li>
<li>Cells: Each individual cell on the grid and its passable status</li>
<li>Paths: Draws the current calculated path components</li>
</ul>
<p>First, add the <code>NorthstarDebugPlugin</code> to your app.</p>
<p>Then insert the <code>DebugGrid</code> component a child of the entity that the <code>Grid</code> you want to debug is attached to. </p>
<p>You will likely also want to add a <code>DebugOffset</code> component to the same entity as <code>DebugGrid</code> to align the gizmos with your world tilemap position. In this example we'll be using components from bevy_ecs_tilemap to assist with determining our offset.</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tilemap::prelude::*;
use bevy_northstar::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(NorthstarPlugin::&lt;CardinalNeighborhood&gt;::default())
        // Adding the NorthstarDebugPlugin
        // You need to specify the neighborhood here as well
        .add_plugins(NorthstarDebugPlugin::&lt;CardinalNeighborhood&gt;::default())
        .add_systems(Startup, startup)
        .run();
}

fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    // Query or create your bevy_ecs_tilemap TilemapAnchor
    let anchor = TilemapAnchor::Center;

    // Query or create your bevy_ecs_tilemap TilemapSize, TilemapGridSize, and TilemapTileSize. They are required for calculating the anchor offset.
    let tilemap_size = TilemapSize { x: 64, y: 64 };
    let tilemap_gridsize = TilemapGridSize { x: 8.0, y: 8.0 };
    let tilemap_tilesize = TilemapTileSize { x: 8.0, y: 8.0 };

    // Store our offset
    let offset = anchor.as_offset(
        &amp;tilemap_size,
        &amp;tilemap_gridsize,
        &amp;tilemap_tilesize,
        &amp;TilemapType::Square,
    );

    // Let's pretend we loaded a tilemap asset and stored it in a handle and now we're spawning the entity for it.
    let mut map_entity = commands.spawn(anchor);

    // Call `build()` to return the component.
    let debug_grid = DebugGridBuilder::new(64, 64)
        .enable_chunks()
        .enable_entrances()
        .build();


    // Spawn an entity with the Grid and DebugMap component as a child of the map entity.
    let grid_entity = map_entity.with_child(
        CardinalGrid::new(&amp;GridSettingsBuilder::new_2d(64, 64).build())
    );

    grid_entity.with_child((
        debug_grid,
        DebugOffset(offset)
    ));
}
</code></pre></pre>
<h1 id="debugging-paths"><a class="header" href="#debugging-paths">Debugging Paths</a></h1>
<p>Debugging paths for an entity requires you to add a <code>DebugPath</code> component to the entity or entities of your choosing. This component allows you to selectively debug specific paths.</p>
<p>Drawing the path gizmos also requires the <code>NorthstarDebugPlugin</code> to add the gizmo drawing system.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands.spawn((
    Name::new(&quot;Player&quot;),
    DebugPath::new(Color::srgb(1.0, 0.0, 0.0)),
));
<span class="boring">}
</span></code></pre></pre>
<p>If you would like to debug a directly created path (returned from <code>grid::pathfind()</code>) make sure you attach the returned <code>Path</code> component to your entity. If you're not using <code>NorthstarPlugin</code> you will also need to make sure the entity has an <code>AgentPos</code> component. This is the query filter used to debug paths <code>Query&lt;(&amp;DebugPath, &amp;Path, &amp;AgentOfGrid)&gt;</code>.</p>
<h1 id="debuggridbuilder-settings"><a class="header" href="#debuggridbuilder-settings">DebugGridBuilder Settings</a></h1>
<h3 id="isometric"><a class="header" href="#isometric"><code>isometric()</code></a></h3>
<p>Sets the debug gizmos to draw in isometric perspective.</p>
<h3 id="enable_chunks"><a class="header" href="#enable_chunks"><code>enable_chunks()</code></a></h3>
<p>Outline the grid chunk regions.</p>
<img src="../bevy_northstar/images/debugchunk.png" width="300"/>
<h3 id="enable_entrances"><a class="header" href="#enable_entrances"><code>enable_entrances()</code></a></h3>
<p>Highlights the entrances created between each chunk. Very useful for debugging HPA* issues.</p>
<img src="../bevy_northstar/images/debugentrances.png" width="300"/>
<h3 id="enable_cells"><a class="header" href="#enable_cells"><code>enable_cells()</code></a></h3>
<p>Overlay over each tile whether it's passable or impassable. Useful for debugging if you're calling <code>set_nav</code> correctly for your tilemap. </p>
<img src="../bevy_northstar/images/debugcells.png" width="300"/>
<h3 id="enable_cached_paths"><a class="header" href="#enable_cached_paths"><code>enable_cached_paths()</code></a></h3>
<p><code>Grid</code> precaches paths between all entrances inside each chunk. Noisy, but can help debug HPA* pathing issues.</p>
<img src="../bevy_northstar/images/debugcachedpaths.png" width="300"/>
<h3 id="enable_show_connections_on_hover"><a class="header" href="#enable_show_connections_on_hover"><code>enable_show_connections_on_hover()</code></a></h3>
<p>As you can see above, viewing all the connections at once is quite noisy. Enabling show_connections_on_hover will only draw chunk entrance cached connections when the <code>DebugCursor</code> position is over the node. Very useful for debugging possible failed node connections without all of the other connections overlapping.</p>
<img src="../bevy_northstar/images/debugonlyonhover.png" width="300"/>
<h1 id="debugcursor-component"><a class="header" href="#debugcursor-component"><code>DebugCursor</code> Component</a></h1>
<p>In order for the debug plugin to determine which node your cursor is hovering over, you need to manually update the <code>DebugCursor</code> component. While tedious this is required because not every game will have the same windowing and camera setups. <code>DebugCursor</code> is inserted along with <code>DebugGrid</code> so there is no need to insert it manually.</p>
<p>For most cases you can just dump the raw world cursor position in your input systems or just add a simple system to handle it:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_debug_cursor(
    window: Single&lt;&amp;Window&gt;,
    camera: Single&lt;(&amp;Camera, &amp;GlobalTransform)&gt;,
    debug_cursor: Single&lt;&amp;mut DebugCursor&gt;,
) {
    let window = window.into_inner();
    let (camera, camera_transform) = camera.into_inner();
    let mut debug_cursor = debug_cursor.into_inner();

    if let Some(cursor_position) = window
        .cursor_position()
        .and_then(|cursor| camera.viewport_to_world_2d(camera_transform, cursor).ok())
    {
        debug_cursor.0 = Some(cursor_position);
    } else {
        debug_cursor.0 = None;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="25d-debugging"><a class="header" href="#25d-debugging">2.5D Debugging</a></h1>
<p>Drawing all 3D grid debug gizmos over a 2d tilemap render would get pretty noisy so the debug drawing generally only draws information for one z depth at a time. The exception for this is that all entrance nodes will be drawn and y offsets for height will be applied.</p>
<p>You can set the depth with an inspector or use <code>DebugGrid::set_depth(depth: u32)</code> to change the depth that is being drawn.</p>
<p>In 2.5D maps each depth layer will generally have a Y offset applied so the tile appears higher to the player. The <code>DebugDepthYOffsets</code> component is used so the debugging systems know which offsets to apply when drawing at that z depth. <code>DebugDepthYOffsets</code> takes a <code>HashMap&lt;u32, f32&gt;</code> where the key is the z depth and the value is the offset.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>DebugDepthYOffsets(
    HashMap::from([
        (0, 0.0),
        (1, 16.0),
        (2, 32.0),
    ])
)
<span class="boring">}
</span></code></pre></pre>
<h1 id="stats-1"><a class="header" href="#stats-1">Stats</a></h1>
<p>Enabling the <code>stats</code> feature on the crate will allow the <code>NorthstarPlugin</code> pathfinding systems to calculate the average time spent on pathfinding and collision calls.</p>
<p>It will also log debug level stats for <code>Grid::build()</code> times. Useful making sure your grid rebuilds are staying within your frame budget.</p>
<pre><code class="language-toml">[dependencies]
bevy_northstar = { version = &quot;0.2.0&quot;, features = [&quot;stats&quot;]}
</code></pre>
<p>You can access the statistics from the <code>Stats</code> <code>Resource</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_stats(stats: Res&lt;Stats&gt;) {
    debug!(&quot;Collision Stats: {:?}&quot;, stats.collision);
    debug!(&quot;Pathfinding Stats: {:?}&quot;, stats.pathfinding);
}
<span class="boring">}
</span></code></pre></pre>
<p>To get the <code>Grid::build()</code> timing stats dumped to your log you'll need to enable debug level logging for the crate.</p>
<pre><code class="language-bash no-run">RUST_LOG=bevy_northstar=debug,bevy=info cargo run
</code></pre>
<p>Or alternatively configure it in code when setting up your Bevy logging.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-v02x-to-v03x"><a class="header" href="#migrating-from-v02x-to-v03x">Migrating From v0.2.X to v0.3.X</a></h1>
<h2 id="gridsettings--gridsettingsbuilder"><a class="header" href="#gridsettings--gridsettingsbuilder">GridSettings → GridSettingsBuilder</a></h2>
<p><code>GridSettings</code> has been replaced with <code>GridSettingsBuilder</code>.</p>
<p>Replace</p>
<pre><code class="language-rust no_run ignore">let grid_settings = GridSettings {
    width: 16,
    height: 16,
    chunk_size: 4,
    collision: true,
    ..Default::default()
}

let grid = CardinalGrid::new(&amp;grid_settings);
</code></pre>
<p>with</p>
<pre><code class="language-rust no_run ignore">let grid_settings = GridSettingsBuilder::new_2d(16, 16)
    .chunk_size(4)
    .enable_collision()
    .build();

let grid = CardinalGrid::new(&amp;grid_settings);
</code></pre>
<h2 id="gridpos--agentpos"><a class="header" href="#gridpos--agentpos">GridPos → AgentPos</a></h2>
<p><code>GridPos</code> has been renamed to <code>AgentPos</code>. This is just a simple rename for clarity.</p>
<h2 id="point--navcell-nav--wall---passable-impassable"><a class="header" href="#point--navcell-nav--wall---passable-impassable">Point → NavCell, Nav | Wall -&gt; Passable, Impassable</a></h2>
<p><code>Point</code> has been reworked for clarity. <code>Point</code> has been renamed to <code>NavCell</code> but the API has been updated to remove user's need to interact with <code>NavCell</code> for normal use.</p>
<p><code>Grid</code> functions now take the <code>Nav</code> enum to definite mobility and movement cost for a <code>Grid</code> cell.</p>
<p>Replace</p>
<pre><code class="language-rust no_run ignore">import bevy_northstar::prelude::*;

let grid_settings = GridSettingsBuilder::new_2d(16, 16, 0);
let mut grid = CardinalGrid::new(&amp;grid_settings);

// Creates a wall at grid cell 8,8,0
grid.set_point(UVec3::new(8, 8, 0), Point::new(u32::MAX, true));
// Set the cost for a passable grid cell
grid.set_point(UVec3::new(4, 4, 0), Point::new(4, false));
</code></pre>
<p>with</p>
<pre><code class="language-rust no_run ignore">grid.set_nav(UVec3::new(8, 8, 0), Nav::Impassable);
grid.set_nav(UVec3::new(4, 4, 0), Nav::Passable(4));
</code></pre>
<h2 id="pathfind-component-rework-new-pathfindmode"><a class="header" href="#pathfind-component-rework-new-pathfindmode">Pathfind Component Rework, New PathfindMode</a></h2>
<p>The <code>Pathfind</code> component has been reworked with chaining setup functions to ensure configuration can be added in the future without breaking changes.</p>
<p><code>PathfindMode</code> enum was added set which pathfinding method is desired.</p>
<p>Before</p>
<pre><code class="language-rust no_run ignore">// You may have forced an A* path like this before
.insert(Pathfind {
    goal: UVec3::new(8, 8, 0),
    use_astar: true,
})
// or the shorthand for regular HPA*
.insert(Pathfind::new(UVec3::new(8, 8, 0)))
// shorthand A*
.insert(Pathfind::new_astar(UVec3::new(8, 8, 4)))
</code></pre>
<p>Is now</p>
<pre><code class="language-rust no_run ignore">.insert(Pathfind::new(UVec3::(8, 8, 0).mode(PathfindMode::AStar)))

// You can use the new_2d and new_3d constructors without creating a UVec as well
.insert(Pathfind::new_2d(8, 8))
.insert(Pathfind::new_3d(8, 8, 4).mode(PathfindMode::AStar))
</code></pre>
<h2 id="debugmap--debuggrid-debuggridbuilder--debugoffset"><a class="header" href="#debugmap--debuggrid-debuggridbuilder--debugoffset">DebugMap → DebugGrid, DebugGridBuilder, &amp; DebugOffset</a></h2>
<p><code>DebugMap</code> has been renamed to <code>DebugGrid</code> for clarity and a builder pattern has been added to make it cleaner to configure.</p>
<p>It was recommended before to put <code>DebugMap</code> as the child of your <code>Grid</code> entity, but it is now <strong>required</strong>.</p>
<p>Change</p>
<pre><code class="language-rust no_run ignore">grid_entity.with_child((
    DebugMap {
        tile_width: 8,
        tile_height: 8,
        map_type: DebugMapType::Square,
        draw_chunks: true,
        draw_points: false,
        draw_entrances: true,
        draw_cached_paths: false,
    },
    Transform::from_translation(offset.extend(0.0)),
));
</code></pre>
<p>to</p>
<pre><code class="language-rust no_run ignore">grid_entity.with_child((
    DebugGridBuilder::new(8, 8)
        .enable_chunks()
        .enable_entrances()
        .build(),
    // Add the offset to the debug gizmo so that it aligns with your tilemap.
    DebugOffset(Vec2::new(-360.0, -500.0)),
));
</code></pre>
<p><code>DebugMapType</code> has been renamed to <code>DebugTilemapType</code>. You only need to set it if you're using isometric. <code>DebugGridBuilder::new(8, 8).isometric().build()</code>.</p>
<h2 id="debugpath"><a class="header" href="#debugpath">DebugPath</a></h2>
<p><code>tile_width</code>, <code>tile_height</code>, and <code>map_type</code> has been removed from the <code>DebugPath</code> component.</p>
<p>These fields are now determined by getting the attached <code>DebugGrid</code> based on the entities relationship to the <code>Grid</code> component. Ensure that you add the <code>AgentOfGrid</code> relationship to your pathfinding (player/npc etc) entities.</p>
<p>Replace</p>
<pre><code class="language-rust no_run ignore">.insert(DebugPath {
    tile_width: 8,
    tile_height: 8,
    map_type: DebugMapType::Square,
    color,
    draw_unrefined: false,
})
</code></pre>
<p>with</p>
<pre><code class="language-rust no_run ignore">.insert(DebugPath::new(color))
.insert(AgentOfGrid(grid_entity))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-v03x-to-v04x"><a class="header" href="#migrating-from-v03x-to-v04x">Migrating From v0.3.X to v0.4.X</a></h1>
<h2 id="gridpathfinding-gridpathfinding_astar-gridpathfinding_coarse"><a class="header" href="#gridpathfinding-gridpathfinding_astar-gridpathfinding_coarse">Grid::pathfinding, Grid::pathfinding_astar, Grid::pathfinding_coarse</a></h2>
<p><code>Grid::pathfinding</code> now handles all algorithms and only takes a single argument: <code>PathfindArgs</code>.
<code>PathfindArgs</code> is a builder to reduce the number of arguments required to pass to the pathfinding method.</p>
<p>You will need to update any manual pathfinding calls to use <code>PathfindArgs</code></p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let grid = grid.into_inner();
let (player, grid_pos, move_action) = player.into_inner();

// Request a start (grid_pos.0) to goal (move_action.0) using the AStar algorithm.
let path = grid.pathfind(
    PathfindArgs::new(grid_pos.0, move_action.0).astar()
);
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
