<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bevy_northstar Documentation</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="pathfinding.html"><strong aria-hidden="true">2.</strong> Pathfinding</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">4.</strong> Debugging</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">bevy_northstar Documentation</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/jtothethree/bevy_northstar"><code>bevy_northstar</code></a> is a <a href="https://alexene.dev/2019/06/02/Hierarchical-pathfinding.html"><code>Hierarchical Pathfinding</code></a> plugin for <a href="https://bevy.org/">Bevy</a>.</p>
<p>The crate provides:</p>
<ul>
<li>
<p>Pathfinding Grids: A grid represents the walkable space used for the pathfinding alogrithsm and also precalculated chunks, entrances, and internal paths used for HPA*.</p>
</li>
<li>
<p>Pathfinding Systems: Bevy systems to handle pathfinding and collision for you. They are not required to use HPA* or other pathfinding algorithms.</p>
</li>
<li>
<p>Pathfinding Algorithms: You can call the pathfinding functions easily if you desire to handle the pathfinding logic in your own systems.</p>
</li>
<li>
<p>Debugging Tools: Easily visualize the grid and calculated paths to troubleshoot any tilemap and pathfinding issues.</p>
</li>
</ul>
<p>The crate is currently designed for use with 2d and 3d grid based tilemaps. It is not dependent on any specific tilemap Bevy crate, though it's been designed for ease of use with <a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a> and any related crates such as <a href="https://github.com/adrien-bon/bevy_ecs_tiled"><code>bevy_ecs_tiled</code></a> and <a href="https://github.com/Trouv/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code></a>.</p>
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Add required dependencies to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
bevy = &quot;0.16&quot;
bevy_northstar = &quot;0.2&quot;
</code></pre>
<p>The basic requirements to use the crate are to spawn an entity with a <code>Grid</code> component, adjust the points, and then call <code>Grid::build()</code> so the chunk entrances and internal paths can be calculated. </p>
<p>To use the built-in pathfinding systems for the crate, insert the NorthstarPlugin specifying the <code>Neighborhood</code> to use.</p>
<p>The built-in neighborhoods are:</p>
<ul>
<li><code>CardinalNeighborhood</code> 4 directions allowing no diagonal movement.</li>
<li><code>CardinalNeighborhood3d</code> 6 directions, including up and down, allowing no diagonal movement.</li>
<li><code>OrdinalNeighborhood</code> 8 directions allowing for diagonal movement.</li>
<li><code>OrdinalNeighborhood3d</code> 26 directions which includes the base ordinal movements and their up/down directions.</li>
</ul>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_northstar::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // Add the Northstar Plugin with a selected neighborhood to use the built in pathfinding systems
        .add_plugins(NorthstarPlugin::&lt;CardinalNeighborhood&gt;::default())
        .add_systems(Startup, (startup, build_grid.after(startup)))
        .run();
}

fn startup(mut commands: Commands) {
    commands.spawn(Camera2d::default());

    // Spawn the grid used for pathfinding.
    commands.spawn(Grid&lt;CardinalNeighborhood&gt;::new(&amp;GridSettings {
        width: 16,
        height: 16,
        chunk_size: 4,
        ..Default::default()
    }));
}

fn build_grid(grid: Single&lt;&amp;mut Grid&lt;CardinalNeighborhood&gt;&gt;) {
    let mut grid = grid.into_inner();

    // Let's set the position 8, 8 to a wall
    grid.set_point(UVec3::new(8, 8, 0), Point::new(u32::MAX, true));

    info!(&quot;Building the grid...&quot;);

    // The grid needs to be built after setting the points.
    // Building the grid will calculate the chunk entrances and cache internal paths.
    grid.build();

    info!(&quot;Grid built successfully!&quot;);
}
</code></pre></pre>
<h2 id="grid-generic-neighborhood-shorthand-types"><a class="header" href="#grid-generic-neighborhood-shorthand-types">Grid Generic Neighborhood Shorthand Types</a></h2>
<p>The following shorthand types are also available for constructing and referencing a <code>Grid::&lt;N&gt;</code>.</p>
<ul>
<li>CardinalGrid</li>
<li>CardinalGrid3d</li>
<li>OrdinalGrid</li>
<li>OrdinalGrid3d</li>
</ul>
<p>Rather than <code>Grid&lt;CardinalNeighborhood&gt;::new</code> you can use <code>CardinalGrid::new</code>.
Rather than querying <code>Single&lt;&amp;mut Grid&lt;CardinalNeighborhood&gt;&gt;</code> you can query <code>Single&lt;&amp;mut CardinalGrid&gt;</code></p>
<h2 id="grid-as-a-component"><a class="header" href="#grid-as-a-component">Grid as a Component</a></h2>
<p>Currently the plugin Pathfinding and Debug systems expect there to be only a single copy of the Grid component which means you can't currently use them if you want to support multiple grids in your project. </p>
<p>Normally it would make sense for this to be Bevy <code>Resource</code> but this decision was made so the plugin can update to support multiple grids in the future without making breaking API changes. If your project needs to support multiple pathfinding grids you can avoid using the NorthstarPlugin and NorthstarDebugPlugin and call the pathfinding functions directly on the <code>Grid</code> components for the time being.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pathfinding-with-built-in-systems"><a class="header" href="#pathfinding-with-built-in-systems">Pathfinding With Built-In Systems</a></h1>
<h2 id="pathfind-and-gridpos-components"><a class="header" href="#pathfind-and-gridpos-components">Pathfind and GridPos Components</a></h2>
<p>To use the <code>NorthstarPlugin</code> pathfinding systems, insert a <code>Pathfind</code> and <code>GridPos</code> component.</p>
<p>The <code>GridPos</code> you will need to maintain as the current GridPos of the entity.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands
    .spawn((
        Name::new(&quot;Player&quot;),
        Pathfind {
            goal: UVec3::new(12, 12, 0),
            // you can set use_astar to true to bypass HPA* and use the traditional A* pathfinding algorithm if desired.
            use_astar: false,
        },
        GridPos(UVec3::new(1, 1, 0)),
        Blocking, // Insert the Blocking component if using collision and this entity should block.
    ));
<span class="boring">}
</span></code></pre></pre>
<p>There are also shortened functions for creating a new component using HPA* or A*</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands
    .spawn((
        Name::new(&quot;Player&quot;),
        // new will default to HPA*.
        Pathfind::new(UVec3::new(12, 12, 0)),
        GridPos(UVec3::new(1, 1, 0)),
        Blocking, // Insert the Blocking component if using collision and this entity should block.
    ))
    .spawn((
        Name::new(&quot;Npc&quot;),
        // new_astar will default to using A*.
        Pathfind::new_astar(UVec3::new(14, 14, 0)),
        GridPos(UVec3::new(2, 2, 0)),
        Blocking,
    ));
<span class="boring">}
</span></code></pre></pre>
<h2 id="nextpos"><a class="header" href="#nextpos">NextPos</a></h2>
<p>The <code>pathfind</code> system looks for any entity with a <code>Changed</code> <code>Pathfind</code> component. It then runs the pathfinding algorithm and when a valid path is found it will insert the next position in the path as a <code>NextPos</code> component.</p>
<p>Consume the <code>NextPos</code> component by handling the movement and then remove the <code>NextPos</code> component. The <code>next_position</code> system will insert a new <code>NextPos</code> component in a later frame. </p>
<p>If collision is enabled the <code>next_position</code> system will also handle local collision avoidance and adjust the entities path if there is a blocking entity in the path in the <code>avoidance_distance</code> look ahead set in <code>GridSettings</code>.</p>
<p>Example movement system:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn movement(
    mut commands: Commands,
    mut query: Query&lt;(Entity, &amp;mut GridPos, &amp;NextPos)&gt;,
) {
    for (entity, mut grid_pos, next_pos) in query.iter_mut() {
        // Set the entities GridPos to the NextPos UVec3.
        grid_pos.0 = next_pos.0;

        // Update the entities translation
        let translation = Vec3::new(
            next.0.x as f32 * 32.0, // Assuming tiles are 32x32
            next.0.y as f32 * 32.0,
            0.0
        );

        commands.entity(entity)
            .insert(Transform::from_translation(translation))
            .remove::&lt;NextPos&gt;();
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="pathfindingcollision-marker-components"><a class="header" href="#pathfindingcollision-marker-components">Pathfinding/Collision Marker Components</a></h2>
<p><code>PathfindingFailed</code> will inserted into the entity if a path is not found for the desired goal. You can create your own system to handle these failures, or let the built-in system attempt another pathfind for the goal on the next frame.</p>
<p><code>AvoidanceFailed</code> will be inserted when collision is enabled and the entity is not able to path around a local blocking entity. The <code>reroute_path</code> system will attempt to find a new full HPA* path in an attempt to resolve the issue. You can handle these in your own custom system if desired.</p>
<p><code>RerouteFailed</code> is added to the component when all attempts to resolve collision pathing issues have failed and means that there's no viable path at all to the entities desired goal. At this point you will need to handle the issue in your own custom system. Whether this is looking for a new goal or waiting a set amount of time before attempting pathing is up to you. Remove the <code>RerouteFailed</code> component from the entity when the entity is ready to attempt pathfinding again.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_reroute_failed(
    mut commands: Commands,
    mut query: Query&lt;(Entity, &amp;Pathfind), With&lt;&amp;RerouteFailed&gt;&gt;,
) {
    for (entity, pathfind) {
        let some_new_goal = UVec3::new(3, 30, 0); // Just some random new goal
        commands
            .entity(entity)
            .insert(Pathfind::new(some_new_goal)
            .remove::&lt;RerouteFailed&gt;();
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="manual-pathfinding"><a class="header" href="#manual-pathfinding">Manual Pathfinding</a></h1>
<p>You don't need to use the pathfinding systems in the <code>NorthstarPlugin</code> in order to take advantage of this crate. </p>
<p>You can use both, or choose to not add the <code>NorthstarPlugin</code> and call the pathfinding functions completely manually.</p>
<p>If you don't use <code>NorthstarPlugin</code> you'll need to maintain your own <code>BlockingMap</code> or <code>HashMap&lt;UVec3, Entity&gt;</code> to pass to the <code>pathfind</code> function to provide it a list of blocked positions.</p>
<p>All of the pathfinding calls can be done on the <code>Grid</code> component.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn manual_pathfind(
    mut commands: Commands,
    player: Single&lt;(Entity, &amp;GridPos, &amp;MoveAction), With&lt;Player&gt;&gt;,
    grid: Single&lt;&amp;CardinalGrid&gt;,
    // If using collision you can use the BlockingMap resource to track blockers.
    blocking: Res&lt;BlockingMap&gt;,
) {
    let grid = grid.into_inner();
    let (player, grid_pos, move_action) = player.into_inner();

    let path = grid.pathfind(grid_pos.0, move_action.0, blocking, true);

    // Setting use_partial to true will allow the pathfinding to return a partial path if a complete path isn't found.

    // If you're not using collision you can pass an empty hashmap for the blocking map.
    let path = grid.pathfind(grid_pos.0, move_action.0, HashMap::new(), true);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-guide"><a class="header" href="#configuration-guide">Configuration Guide</a></h1>
<h2 id="gridsettings"><a class="header" href="#gridsettings">GridSettings</a></h2>
<p><code>width</code>: Set this to tile count width of your tilemap.</p>
<p><code>height</code>: The tile count height of your tilemap.</p>
<p><code>depth</code>: Set to 1 for 2d tilemaps. If using a 3d tilemap set this to the height of your tilemap.</p>
<p><code>chunk_size</code>: How many chunks to divide the tilemap into for HPA*. You'll want to find a good middle ground for this value depending on the size of your map. Larger chunks will assist with performance but provide less optimal paths, smaller chunks will give more optimal paths while hitting performance.</p>
<p><code>chunk_ordinal</code>: If set to true, entrances will be added to the corners of chunks. This will make <code>Grid::build</code> take a significantly longer for large maps. In most cases this isn't necessary, but may be considered if your map is noisy with a lot of corners and you allow diagonal movement.</p>
<p>For example a map where wall corners meet often with a diagonal gap.</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>x</td><td>o</td></tr>
<tr><td>o</td><td>x</td></tr>
</tbody></table>
<p><code>default_cost</code>: This sets default cost for every point of the grid. Set to 0 or 1 for cheap movement. Set to 255 if you want the cost to be the highest.</p>
<p><code>default_wall</code>: Set to true if you want every point in the grid to a be a wall by default. </p>
<p><code>collision</code>: Set to true to allow the plugins pathfinding systems to ensure entities aren't pathing through each other.</p>
<p><code>avoidance_distance</code>: The plugin uses local collision avoidance mainly for performance purposes. This sets the lookahead distance in grid points to check for any possible blocking entity in it's path.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-the-grid-component"><a class="header" href="#debugging-the-grid-component">Debugging the Grid component</a></h1>
<p>The <code>NorthstarDebugPlugin</code> adds systems that can be enabled to draw gizmos to display the following:</p>
<ul>
<li>Chunk grid: Grid outline of where the chunks are</li>
<li>Entrances: Calculated entrances at the boundaries of the chunks</li>
<li>Cached internal paths: Cached paths inside the chunk between its own entrances.</li>
<li>Points: Each individual point on the grid and it's walkable status</li>
<li>Paths: Draws the current calculated path components</li>
</ul>
<p>First, add the <code>NorthstarDebugPlugin</code> to your app.</p>
<p>Second, you will likely want to set the transform offset to align it with your tilemap. In this example we'll be using components from bevy_ecs_tilemap to assist with determining our offset.</p>
<p>Third, insert the <code>DebugMap</code> component to the same entity as your <code>Grid</code>. Currently doing this won't change anything, but in the future the Plugin will likely use that to match up <code>DebugMap</code> with it's <code>Grid</code> when multiple <code>Grid</code>s are supported.</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tilemap::prelude::*;
use bevy_northstar::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(NorthstarPlugin::&lt;CardinalNeighborhood&gt;::default())
        // Adding the NorthstarDebugPlugin
        // You need to specify the neighborhood here as well
        .add_plugins(NorthstarDebugPlugin::&lt;CardinalNeighborhood&gt;::default())
        .add_systems(Startup, startup)
        .run();
}

fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    // Query or create your bevy_ecs_tilemap TilemapAnchor
    let anchor = TilemapAnchor::Center;

    // Query or create your bevy_ecs_tilemap TilemapSize, TilemapGridSize, and TilemapTileSize. They are required for calculating the anchor offset.
    let tilemap_size = TilemapSize { x: 128, y: 128 };
    let tilemap_gridsize = TilemapGridSize { x: 8.0, y: 8.0 };
    let tilemap_tilesize = TilemapTileSize { x: 8.0, y: 8.0 };

    // Store our offset
    let offset = anchor.as_offset(
        &amp;tilemap_size,
        &amp;tilemap_gridsize,
        &amp;tilemap_tilesize,
        &amp;TilemapType::Square,
    );

    // Let's pretend we loaded a tilemap asset and stored it in a handle and now we're spawning the entity for it.
    let mut map_entity = commands.spawn(anchor);

    // Spawn an entity with the Grid and DebugMap component as a child of the map entity.
    map_entity.with_child(
        CardinalGrid::new(&amp;GridSettings {
            width: 128,
            height: 128,
            ..default::Default()
        }),
        DebugMap {
            tile_width: 8,
            tile_height: 8,
            map_type: DebugMapType::Square,
            draw_chunks: true,
            draw_points: false,
            draw_entrances: true,
            draw_cached_paths: false,
        },
        // Use our offset calculated from the bevy_ecs_tilemap anchor to set the transform of the DebugMap entity.
        Transform::from_translation(offset.extend(0.0))
    )
}
</code></pre></pre>
<h1 id="debugging-paths"><a class="header" href="#debugging-paths">Debugging Paths</a></h1>
<p>Debugging calculated paths for an entity requires you to add a <code>DebugPath</code> component to the entity or entities of your choosing. This component allows you to selectively debug specific paths.</p>
<p>Drawing the path gizmos also requires the <code>NorthstarDebugPlugin</code> to add the gizmo drawing system.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_northstar::prelude::*;

commands.spawn((
    Name::new(&quot;Player&quot;),
    DebugPath {
        // Width of the tilemap tiles
        tile_width: 8,
        // Height of the tilemap tiles
        tile_height: 8,
        // Map Type (Square or Isometric)
        map_type: DebugMapType::Square,
        // Color of the path gizmos
        color: Color::srgb(1.0, 0.0, 0.0)
    },
))
<span class="boring">}
</span></code></pre></pre>
<h1 id="stats"><a class="header" href="#stats">Stats</a></h1>
<p>Enabling the <code>stats</code> feature on the crate will allow the <code>NorthstarPlugin</code> pathfinding systems to calculate how much time is spent per frame on pathfinding and collison.</p>
<pre><code class="language-toml">[dependencies]
bevy_northstar = { version = &quot;0.2.0&quot;, features = [&quot;stats&quot;]}
</code></pre>
<p>You can access the statistics from the <code>Stats</code> <code>Resource</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_stats(stats: Res&lt;Stats&gt;) {
    debug!(&quot;Collision Stats: {:?}&quot;, stats.collision);
    debug!(&quot;Pathfinding Stats: {:?}&quot;, stats.pathfinding);
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
